import curses
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import networkx as nx

# Initialize the tape and Turing machine states
tape = np.zeros(1840, dtype=int)
transitions = np.zeros((100, 2, 3), dtype=int)
cursor_x, cursor_y = 40, 11
initial_state = 1
max_cycles = 0
done = False

# Subroutine to initialize the tape and display
def initialize_screen(stdscr):
    stdscr.clear()
    stdscr.addstr(0, 2, "EMULADOR DE MAQUINA DE TURING.                   (C)1994 RASTER SOFTWARE VIGO")
    for n in range(2, 25):
        for f in range(1, 81):
            stdscr.addstr(n, f, str(tape[f + (n - 2) * 80]))
    stdscr.refresh()

# Subroutine to display the menu
def display_menu(stdscr):
    stdscr.clear()
    stdscr.addstr(10, 28, "1=LIMPIAR LA CINTA")
    stdscr.addstr(11, 28, "2=ACTUALIZAR LA CINTA")
    stdscr.addstr(12, 28, "3=PROGRAMAR LA MAQUINA")
    stdscr.addstr(13, 28, "4=EJECUCION NORMAL")
    stdscr.addstr(14, 28, "5=EJECUCION PASO A PASO")
    stdscr.addstr(15, 28, "6=OPCIONES")
    stdscr.addstr(16, 28, "7=SALIR")
    stdscr.refresh()

def main(stdscr):
    global cursor_x, cursor_y, initial_state, max_cycles, done

    curses.curs_set(0)
    stdscr.clear()
    initialize_screen(stdscr)
    
    while True:
        display_menu(stdscr)
        choice = stdscr.getch()
        
        if choice == ord('1'):
            tape.fill(0)
            cursor_x, cursor_y = 40, 11
            done = False
            initialize_screen(stdscr)
        
        elif choice == ord('2'):
            update_tape(stdscr)
        
        elif choice == ord('3'):
            program_machine(stdscr)
        
        elif choice == ord('4'):
            run_machine(stdscr, False)
        
        elif choice == ord('5'):
            run_machine(stdscr, True)
        
        elif choice == ord('6'):
            options(stdscr)
        
        elif choice == ord('7'):
            break

def update_tape(stdscr):
    global cursor_x, cursor_y

    initialize_screen(stdscr)
    stdscr.addstr(25, 1, "    O,P,Q,A MUEVE EL CURSOR;  0-1 CAMBIA EL SIMBOLO;  ESPACIO VUELVE AL MENU")
    stdscr.refresh()
    
    while True:
        stdscr.move(cursor_y, cursor_x)
        stdscr.refresh()
        key = stdscr.getch()
        
        if key == ord(' '):
            break
        elif key in [ord('Q'), ord('q')]:
            cursor_y -= 1
        elif key in [ord('A'), ord('a')]:
            cursor_y += 1
        elif key in [ord('P'), ord('p')]:
            cursor_x += 1
        elif key in [ord('O'), ord('o')]:
            cursor_x -= 1
        elif key in [ord('0'), ord('1')]:
            tape[cursor_x + (cursor_y - 2) * 80] = int(chr(key))
        
        if cursor_x < 1:
            cursor_x = 80
        if cursor_x > 80:
            cursor_x = 1
        if cursor_y > 24:
            cursor_y = 2
        if cursor_y < 2:
            cursor_y = 24
        
        stdscr.addstr(cursor_y, cursor_x, str(tape[cursor_x + (cursor_y - 2) * 80]))
        stdscr.refresh()

def program_machine(stdscr):
    global done

    done = False
    stdscr.clear()
    for f in range(12, 72, 12):
        stdscr.addstr(1, f, str(f // 12 + 48))
    for f in range(9, 61, 12):
        stdscr.addstr(2, f, "0")
        stdscr.addstr(2, f + 6, "1")
    for f in range(3, 23):
        stdscr.addstr(f, 3, str((f - 3) * 5))
    stdscr.addstr(25, 1, " O,P,Q,A MUEVE EL CURSOR;  ENTER PARA MODIFICAR;  N BORRA TODO; ESPACIO RETORNA")
    display_program(stdscr)

    cursor_x, cursor_y = 7, 3
    while True:
        stdscr.addstr(cursor_y, cursor_x, "#")
        stdscr.addstr(cursor_y, cursor_x + 5, "#")
        stdscr.refresh()
        key = stdscr.getch()
        
        if key == ord(' '):
            break
        elif key == curses.KEY_ENTER or key == 10:
            change_program(stdscr)
        elif key in [ord('Q'), ord('q')]:
            cursor_y -= 1
        elif key in [ord('A'), ord('a')]:
            cursor_y += 1
        elif key in [ord('P'), ord('p')]:
            cursor_x += 6
        elif key in [ord('O'), ord('o')]:
            cursor_x -= 6
        elif key in [ord('N'), ord('n')]:
            transitions.fill(0)
            display_program(stdscr)
            cursor_x, cursor_y = 7, 3

        if cursor_y < 3:
            cursor_y = 3
        if cursor_y > 22:
            cursor_y = 22
        if cursor_x > 66:
            if cursor_y < 22:
                cursor_y += 1
                cursor_x = 7
            else:
                cursor_x -= 6
        if cursor_x < 7:
            if cursor_y > 3:
                cursor_y -= 1
                cursor_x = 61
            else:
                cursor_x += 6

def change_program(stdscr):
    global transitions
    stdscr.addstr(cursor_y, cursor_x, "     ")

    while True:
        stdscr.addstr(23, 1, "NUEVO SIMBOLO")
        stdscr.refresh()
        s = stdscr.getstr(23, 14, 1).decode('utf-8')
        if len(s) == 1 and s in ['0', '1']:
            break
        stdscr.addstr(23, 1, "UN SOLO SIMBOLO, POR FAVOR")
        stdscr.refresh()
    
    symbol = int(s)
    stdscr.addstr(cursor_y, cursor_x, s)
    transitions[(cursor_y - 3) * 5 + (cursor_x - 7) // 12 + 1, 1 + ((cursor_x - 7) % 12) // 6, 1] = symbol

    while True:
        stdscr.addstr(23, 1, "NUEVO ESTADO")
        stdscr.refresh()
        s = stdscr.getstr(23, 14, 2).decode('utf-8')
        if len(s) <= 2 and s.isdigit():
            break
        stdscr.addstr(23, 1, "EL ESTADO DEBE ESTAR ENTRE 0 Y 99, POR FAVOR")
        stdscr.refresh()

    state = int(s) + 1
    stdscr.addstr(cursor_y, cursor_x + 2, s)
    transitions[(cursor_y - 3) * 5 + (cursor_x - 7) // 12 + 1, 1 + ((cursor_x - 7) % 12) // 6, 2] = state

    while True:
        stdscr.addstr(23, 1, "NUEVO SENTIDO")
        stdscr.refresh()
        s = stdscr.getstr(23, 14, 1).decode('utf-8')
        if s in ['<', '>']:
            break
        stdscr.addstr(23, 1, "EL ESTADO ES  <  O  > , POR FAVOR")
        stdscr.refresh()

    stdscr.addstr(cursor_y, cursor_x + 4, s)
    direction = 0 if s == '<' else 1
    transitions[(cursor_y - 3) * 5 + (cursor_x - 7) // 12 + 1, 1 + ((cursor_x - 7) % 12) // 6, 3] = direction
    cursor_x += 6

def display_program(stdscr):
    for f in range(3, 23):
        for z in range(5):
            for n in range(1, 3):
                if transitions[(f - 3) * 5 + z + 1, n, 1] != 0:
                    stdscr.addstr(f, 7 + 12 * (z - 1) + 6 * (n - 1), str(transitions[(f - 3) * 5 + z + 1, n, 1]))
                    stdscr.addstr(f, 8 + 12 * (z - 1) + 6 * (n - 1), str(transitions[(f - 3) * 5 + z + 1, n, 2] - 1))
                    stdscr.addstr(f, 10 + 12 * (z - 1) + 6 * (n - 1), '>' if transitions[(f - 3) * 5 + z + 1, n, 3] == 1 else '<')
    stdscr.refresh()

def run_machine(stdscr, step_by_step):
    global cursor_x, cursor_y, initial_state, max_cycles, done

    stdscr.clear()
    initialize_screen(stdscr)
    cursor_x, cursor_y = 40, 11

    state = initial_state
    cycles = 0
    position = 640

    fig, ax = plt.subplots()
    G = nx.DiGraph()
    node_color = []

    for i in range(100):
        if np.any(transitions[i]):
            G.add_node(i, label=f'S{i}')
            node_color.append('blue')

    pos = nx.spring_layout(G)
    nx.draw_networkx_nodes(G, pos, node_size=700, ax=ax)
    nx.draw_networkx_edges(G, pos, ax=ax)
    nx.draw_networkx_labels(G, pos, labels=nx.get_node_attributes(G, 'label'), ax=ax)

    def update(frame):
        global cursor_x, cursor_y, done, state, position

        if done:
            return

        input_symbol = tape[position]
        new_symbol = transitions[state, input_symbol + 1, 1]
        new_state = transitions[state, input_symbol + 1, 2]
        direction = transitions[state, input_symbol + 1, 3]

        if new_state == 0:
            done = True
            return

        tape[position] = new_symbol
        state = new_state
        if direction == 0:
            position -= 1
            cursor_x -= 1
        else:
            position += 1
            cursor_x += 1

        if cursor_x < 1:
            cursor_x = 80
            cursor_y -= 1
        if cursor_x > 80:
            cursor_x = 1
            cursor_y += 1
        if cursor_y < 2:
            cursor_y = 24
        if cursor_y > 24:
            cursor_y = 2

        ax.clear()
        nx.draw_networkx_nodes(G, pos, node_size=700, node_color=node_color, ax=ax)
        nx.draw_networkx_edges(G, pos, ax=ax)
        nx.draw_networkx_labels(G, pos, labels=nx.get_node_attributes(G, 'label'), ax=ax)
        nx.draw_networkx_nodes(G, pos, nodelist=[state], node_color='red', ax=ax)

    ani = FuncAnimation(fig, update, frames=max_cycles, repeat=False)
    plt.show()

    while not done:
        stdscr.refresh()
        if step_by_step:
            key = stdscr.getch()
            if key == ord(' '):
                break

def options(stdscr):
    global initial_state, max_cycles

    stdscr.clear()
    stdscr.addstr(10, 30, "OPCIONES DE EJECUCION")
    stdscr.addstr(12, 15, f"1=ESTADO INICIAL     {initial_state - 1}")
    stdscr.addstr(14, 15, f"2=MAXIMO NUMERO DE CICLOS   {max_cycles}")
    stdscr.addstr(23, 1, "PULSA ESPACIO PARA VOLVER AL MENU")

    while True:
        stdscr.refresh()
        key = stdscr.getch()
        if key == ord(' '):
            break
        elif key == ord('1'):
            stdscr.addstr(23, 1, "NUEVO VALOR")
            stdscr.refresh()
            new_state = stdscr.getstr(23, 12, 2).decode('utf-8')
            initial_state = int(new_state) + 1
            stdscr.addstr(12, 37, new_state)
        elif key == ord('2'):
            stdscr.addstr(23, 1, "NUEVO VALOR")
            stdscr.refresh()
            new_cycles = stdscr.getstr(23, 12, 5).decode('utf-8')
            max_cycles = int(new_cycles)
            stdscr.addstr(14, 42, new_cycles)

if __name__ == "__main__":
    curses.wrapper(main)
